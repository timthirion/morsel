//! Wavefront OBJ format support.
//!
//! This module provides loading and saving of meshes in the Wavefront OBJ format,
//! one of the most widely used mesh file formats.

use std::fs::File;
use std::io::{BufWriter, Write};
use std::path::Path;

use nalgebra::Point3;

use crate::error::{MeshError, Result};
use crate::mesh::{build_from_triangles, to_face_vertex, HalfEdgeMesh, MeshIndex};

/// Load a mesh from an OBJ file.
///
/// # Example
///
/// ```no_run
/// use morsel::io::obj;
/// use morsel::mesh::HalfEdgeMesh;
///
/// let mesh: HalfEdgeMesh = obj::load("model.obj").unwrap();
/// ```
pub fn load<P: AsRef<Path>, I: MeshIndex>(path: P) -> Result<HalfEdgeMesh<I>> {
    let (mesh, _uvs) = load_with_uvs(path)?;
    Ok(mesh)
}

/// Load a mesh and UV coordinates from an OBJ file.
///
/// Returns the mesh and optional UV coordinates (if present in the file).
///
/// # Example
///
/// ```no_run
/// use morsel::io::obj;
/// use morsel::mesh::HalfEdgeMesh;
///
/// let (mesh, uvs): (HalfEdgeMesh, _) = obj::load_with_uvs("model.obj").unwrap();
/// if let Some(uv_map) = uvs {
///     println!("Loaded {} UV coordinates", uv_map.len());
/// }
/// ```
pub fn load_with_uvs<P: AsRef<Path>, I: MeshIndex>(
    path: P,
) -> Result<(HalfEdgeMesh<I>, Option<crate::algo::parameterize::UVMap<I>>)> {
    use nalgebra::Point2;

    let path = path.as_ref();

    let (models, _materials) = tobj::load_obj(path, &tobj::GPU_LOAD_OPTIONS).map_err(|e| {
        MeshError::LoadError {
            path: path.to_path_buf(),
            message: e.to_string(),
        }
    })?;

    if models.is_empty() {
        return Err(MeshError::LoadError {
            path: path.to_path_buf(),
            message: "OBJ file contains no models".to_string(),
        });
    }

    // Combine all models into a single mesh
    let mut all_vertices: Vec<Point3<f64>> = Vec::new();
    let mut all_faces: Vec<[usize; 3]> = Vec::new();
    let mut all_uvs: Vec<Point2<f64>> = Vec::new();
    let mut vertex_offset = 0;
    let mut has_uvs = true;

    for model in &models {
        let mesh = &model.mesh;

        // Extract vertices
        for chunk in mesh.positions.chunks(3) {
            all_vertices.push(Point3::new(
                chunk[0] as f64,
                chunk[1] as f64,
                chunk[2] as f64,
            ));
        }

        // Extract UV coordinates if present
        if mesh.texcoords.len() == mesh.positions.len() / 3 * 2 {
            for chunk in mesh.texcoords.chunks(2) {
                all_uvs.push(Point2::new(chunk[0] as f64, chunk[1] as f64));
            }
        } else {
            has_uvs = false;
        }

        // Extract faces (triangulated)
        for chunk in mesh.indices.chunks(3) {
            if chunk.len() == 3 {
                all_faces.push([
                    chunk[0] as usize + vertex_offset,
                    chunk[1] as usize + vertex_offset,
                    chunk[2] as usize + vertex_offset,
                ]);
            }
        }

        vertex_offset = all_vertices.len();
    }

    if all_faces.is_empty() {
        return Err(MeshError::LoadError {
            path: path.to_path_buf(),
            message: "OBJ file contains no triangles".to_string(),
        });
    }

    let mesh = build_from_triangles(&all_vertices, &all_faces)?;

    let uv_map = if has_uvs && all_uvs.len() == all_vertices.len() {
        Some(crate::algo::parameterize::UVMap::new(all_uvs))
    } else {
        None
    };

    Ok((mesh, uv_map))
}

/// Save a mesh to an OBJ file.
///
/// # Example
///
/// ```no_run
/// use morsel::io::obj;
/// use morsel::mesh::HalfEdgeMesh;
///
/// let mesh: HalfEdgeMesh = HalfEdgeMesh::new();
/// obj::save(&mesh, "output.obj").unwrap();
/// ```
pub fn save<P: AsRef<Path>, I: MeshIndex>(mesh: &HalfEdgeMesh<I>, path: P) -> Result<()> {
    let path = path.as_ref();
    let file = File::create(path)?;
    let mut writer = BufWriter::new(file);

    let (vertices, faces) = to_face_vertex(mesh);

    // Write header comment
    writeln!(writer, "# Generated by morsel")?;
    writeln!(writer, "# Vertices: {}", vertices.len())?;
    writeln!(writer, "# Faces: {}", faces.len())?;
    writeln!(writer)?;

    // Write vertices
    for v in &vertices {
        writeln!(writer, "v {} {} {}", v.x, v.y, v.z)?;
    }

    writeln!(writer)?;

    // Write faces (OBJ uses 1-based indexing)
    for f in &faces {
        writeln!(writer, "f {} {} {}", f[0] + 1, f[1] + 1, f[2] + 1)?;
    }

    writer.flush()?;
    Ok(())
}

/// Save a mesh to an OBJ file with UV coordinates and optional material.
///
/// If `mtl_name` is provided, the OBJ will reference the material file.
///
/// # Example
///
/// ```no_run
/// use morsel::io::obj;
/// use morsel::mesh::HalfEdgeMesh;
/// use morsel::algo::parameterize::{lscm, LSCMOptions, UVMap};
///
/// let mesh: HalfEdgeMesh = morsel::io::load("input.obj").unwrap();
/// let uvs = lscm(&mesh, &LSCMOptions::default()).unwrap();
/// obj::save_with_uvs(&mesh, &uvs, "output.obj", Some("output.mtl")).unwrap();
/// ```
pub fn save_with_uvs<P: AsRef<Path>, I: MeshIndex>(
    mesh: &HalfEdgeMesh<I>,
    uvs: &crate::algo::parameterize::UVMap<I>,
    path: P,
    mtl_name: Option<&str>,
) -> Result<()> {
    let path = path.as_ref();
    let file = File::create(path)?;
    let mut writer = BufWriter::new(file);

    let (vertices, faces) = to_face_vertex(mesh);

    // Write header comment
    writeln!(writer, "# Generated by morsel")?;
    writeln!(writer, "# Vertices: {}", vertices.len())?;
    writeln!(writer, "# Faces: {}", faces.len())?;

    // Reference material file if provided
    if let Some(mtl) = mtl_name {
        writeln!(writer)?;
        writeln!(writer, "mtllib {}", mtl)?;
    }

    writeln!(writer)?;

    // Write vertices
    for v in &vertices {
        writeln!(writer, "v {} {} {}", v.x, v.y, v.z)?;
    }

    writeln!(writer)?;

    // Write texture coordinates
    for i in 0..vertices.len() {
        let uv = uvs.get(crate::mesh::VertexId::new(i));
        writeln!(writer, "vt {} {}", uv.x, uv.y)?;
    }

    writeln!(writer)?;

    // Use material if provided
    if mtl_name.is_some() {
        writeln!(writer, "usemtl material0")?;
        writeln!(writer)?;
    }

    // Write faces with texture coordinates (OBJ uses 1-based indexing)
    // Format: f v1/vt1 v2/vt2 v3/vt3
    for f in &faces {
        writeln!(
            writer,
            "f {}/{} {}/{} {}/{}",
            f[0] + 1,
            f[0] + 1,
            f[1] + 1,
            f[1] + 1,
            f[2] + 1,
            f[2] + 1
        )?;
    }

    writer.flush()?;
    Ok(())
}

/// Create a simple MTL material file with a diffuse texture.
///
/// # Example
///
/// ```no_run
/// use morsel::io::obj;
///
/// obj::write_mtl("output.mtl", "texture.png").unwrap();
/// ```
pub fn write_mtl<P: AsRef<Path>>(path: P, texture_filename: &str) -> Result<()> {
    let path = path.as_ref();
    let file = File::create(path)?;
    let mut writer = BufWriter::new(file);

    writeln!(writer, "# Generated by morsel")?;
    writeln!(writer)?;
    writeln!(writer, "newmtl material0")?;
    writeln!(writer, "Ka 0.2 0.2 0.2")?; // Ambient
    writeln!(writer, "Kd 0.8 0.8 0.8")?; // Diffuse
    writeln!(writer, "Ks 0.0 0.0 0.0")?; // Specular
    writeln!(writer, "illum 1")?; // Illumination model
    writeln!(writer, "map_Kd {}", texture_filename)?; // Diffuse texture map

    writer.flush()?;
    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::io::Write;
    use tempfile::NamedTempFile;

    fn create_temp_obj(content: &str) -> NamedTempFile {
        let mut file = NamedTempFile::with_suffix(".obj").unwrap();
        write!(file, "{}", content).unwrap();
        file
    }

    #[test]
    fn test_load_simple_triangle() {
        let content = r#"
v 0 0 0
v 1 0 0
v 0.5 1 0
f 1 2 3
"#;
        let file = create_temp_obj(content);
        let mesh: HalfEdgeMesh<u32> = load(file.path()).unwrap();

        assert_eq!(mesh.num_vertices(), 3);
        assert_eq!(mesh.num_faces(), 1);
    }

    #[test]
    fn test_roundtrip() {
        let content = r#"
v 0 0 0
v 1 0 0
v 0.5 1 0
v 0.5 -1 0
f 1 2 3
f 2 1 4
"#;
        let input_file = create_temp_obj(content);
        let mesh: HalfEdgeMesh<u32> = load(input_file.path()).unwrap();

        let output_file = NamedTempFile::with_suffix(".obj").unwrap();
        save(&mesh, output_file.path()).unwrap();

        let mesh2: HalfEdgeMesh<u32> = load(output_file.path()).unwrap();

        assert_eq!(mesh.num_vertices(), mesh2.num_vertices());
        assert_eq!(mesh.num_faces(), mesh2.num_faces());
    }
}
