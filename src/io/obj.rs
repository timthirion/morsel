//! Wavefront OBJ format support.
//!
//! This module provides loading and saving of meshes in the Wavefront OBJ format,
//! one of the most widely used mesh file formats.

use std::fs::File;
use std::io::{BufWriter, Write};
use std::path::Path;

use nalgebra::Point3;

use crate::error::{MeshError, Result};
use crate::mesh::{build_from_triangles, to_face_vertex, HalfEdgeMesh, MeshIndex};

/// Load a mesh from an OBJ file.
///
/// # Example
///
/// ```no_run
/// use morsel::io::obj;
/// use morsel::mesh::HalfEdgeMesh;
///
/// let mesh: HalfEdgeMesh = obj::load("model.obj").unwrap();
/// ```
pub fn load<P: AsRef<Path>, I: MeshIndex>(path: P) -> Result<HalfEdgeMesh<I>> {
    let path = path.as_ref();

    let (models, _materials) = tobj::load_obj(path, &tobj::GPU_LOAD_OPTIONS).map_err(|e| {
        MeshError::LoadError {
            path: path.to_path_buf(),
            message: e.to_string(),
        }
    })?;

    if models.is_empty() {
        return Err(MeshError::LoadError {
            path: path.to_path_buf(),
            message: "OBJ file contains no models".to_string(),
        });
    }

    // Combine all models into a single mesh
    let mut all_vertices: Vec<Point3<f64>> = Vec::new();
    let mut all_faces: Vec<[usize; 3]> = Vec::new();
    let mut vertex_offset = 0;

    for model in &models {
        let mesh = &model.mesh;

        // Extract vertices
        for chunk in mesh.positions.chunks(3) {
            all_vertices.push(Point3::new(
                chunk[0] as f64,
                chunk[1] as f64,
                chunk[2] as f64,
            ));
        }

        // Extract faces (triangulated)
        for chunk in mesh.indices.chunks(3) {
            if chunk.len() == 3 {
                all_faces.push([
                    chunk[0] as usize + vertex_offset,
                    chunk[1] as usize + vertex_offset,
                    chunk[2] as usize + vertex_offset,
                ]);
            }
        }

        vertex_offset = all_vertices.len();
    }

    if all_faces.is_empty() {
        return Err(MeshError::LoadError {
            path: path.to_path_buf(),
            message: "OBJ file contains no triangles".to_string(),
        });
    }

    build_from_triangles(&all_vertices, &all_faces)
}

/// Save a mesh to an OBJ file.
///
/// # Example
///
/// ```no_run
/// use morsel::io::obj;
/// use morsel::mesh::HalfEdgeMesh;
///
/// let mesh: HalfEdgeMesh = HalfEdgeMesh::new();
/// obj::save(&mesh, "output.obj").unwrap();
/// ```
pub fn save<P: AsRef<Path>, I: MeshIndex>(mesh: &HalfEdgeMesh<I>, path: P) -> Result<()> {
    let path = path.as_ref();
    let file = File::create(path)?;
    let mut writer = BufWriter::new(file);

    let (vertices, faces) = to_face_vertex(mesh);

    // Write header comment
    writeln!(writer, "# Generated by morsel")?;
    writeln!(writer, "# Vertices: {}", vertices.len())?;
    writeln!(writer, "# Faces: {}", faces.len())?;
    writeln!(writer)?;

    // Write vertices
    for v in &vertices {
        writeln!(writer, "v {} {} {}", v.x, v.y, v.z)?;
    }

    writeln!(writer)?;

    // Write faces (OBJ uses 1-based indexing)
    for f in &faces {
        writeln!(writer, "f {} {} {}", f[0] + 1, f[1] + 1, f[2] + 1)?;
    }

    writer.flush()?;
    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::io::Write;
    use tempfile::NamedTempFile;

    fn create_temp_obj(content: &str) -> NamedTempFile {
        let mut file = NamedTempFile::with_suffix(".obj").unwrap();
        write!(file, "{}", content).unwrap();
        file
    }

    #[test]
    fn test_load_simple_triangle() {
        let content = r#"
v 0 0 0
v 1 0 0
v 0.5 1 0
f 1 2 3
"#;
        let file = create_temp_obj(content);
        let mesh: HalfEdgeMesh<u32> = load(file.path()).unwrap();

        assert_eq!(mesh.num_vertices(), 3);
        assert_eq!(mesh.num_faces(), 1);
    }

    #[test]
    fn test_roundtrip() {
        let content = r#"
v 0 0 0
v 1 0 0
v 0.5 1 0
v 0.5 -1 0
f 1 2 3
f 2 1 4
"#;
        let input_file = create_temp_obj(content);
        let mesh: HalfEdgeMesh<u32> = load(input_file.path()).unwrap();

        let output_file = NamedTempFile::with_suffix(".obj").unwrap();
        save(&mesh, output_file.path()).unwrap();

        let mesh2: HalfEdgeMesh<u32> = load(output_file.path()).unwrap();

        assert_eq!(mesh.num_vertices(), mesh2.num_vertices());
        assert_eq!(mesh.num_faces(), mesh2.num_faces());
    }
}
